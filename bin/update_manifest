#!/usr/bin/env ruby

require 'json'
require 'pp'
require 'byebug'

require_relative "lib/common"
include Repository
HELP = <<EOF

Updates an existing repository manifest.json file by merging in any additional files found in the root directory. If the existing and new manifest files are the same, the existing file will be *overwriten* in place. Be sure you have a backup handy if you're doing this!

	USAGE: #{__FILE__} <content_root_directory> <existing_manifest.json> <new_manifest.json>

	EXAMPLE:
		#{__FILE__} . manifest.json manifest-new.json

EOF

# PLACEHOLDER_GROUP_NAME = 'Ungrouped'


def mimeTypeForFile(path)
	mimeType = nil
	SUPPORTED_MIME_TYPES.each do |k,v|
		if v[:expression].match?(path)
			mimeType = k
			break
		end
	end
	# puts mimeType || path
	mimeType
end

def improveify_name!(item)
	case item['path']
	when /CCWP_/
		item['name'] = "Clinical Content White Paper"
	when /HIMKWP_/
		item['name'] = 'Harmonize and Integrate Member KNARTs White Paper'
	when /ECA_/
		item['name'] = "ECA"
	when /DT_/
		item['name'] = "Documentation Template"
	when /OS_/
		item['name'] = "Order Set"
	when /CRCK_/
		item['name'] = 'Composite Artifact'
	else
		# Keep the existing name
	end

	case item['path']
	when /KVRpt_/
		item['name'] += ' Validation Report'
	when /CSD_/
		item['name'] += ' Conceptual Structure Document'
	end
end
def content_directory_to_item_tree(root)
	content = []
	list = Dir["#{root}/**/**"]
	list.each do |n|
		# puts n
		if(File.file?(n))
			# ext = File.extname(n).downcase[1..-1]
			mimeType = mimeTypeForFile(n)
			name = n.split('/')[1] #.split['.'][0]
			name = name.split('_').collect(&:capitalize).join(' ')
			tags = n.split('/').select{|d| d.length <= 4}
			if mimeType # it's a supported piece of content
				item = rekey({
					'name': name,
					'path': n,
					'mimeType': mimeType,
					'tags': tags
				})
				# Any directory name of 4 characters or less will be treated as a tag automatically
				content << item
			end
		end
	end
	content
end

def existing_manifest_item_for(item, existing)
	existing_item = nil
	existing["groups"].each do |group, i|
		# puts "NAME: #{group['name']}"
		# puts group
		group['items'].each do |n|
			if n['path'] == item['path']
				existing_item = n
				break
			end
		end
	end
	existing_item
end

def existing_manifest_group_for(name, existing)
	existing_group = nil
	existing["groups"].each do |group, i|
		# puts "#{name} #{group['name']}"
		if group['name'].downcase == name.downcase
			existing_group = group
			break
		end
	end
	existing_group
end

# Forces keys to strings.
def rekey(hash)
	hash.collect{|k,v| [k.to_s, v]}.to_h
end
# If the item path is already present *somewhere* in the manifest it will not be merged in, regardless of any differences in the generated and existing item summary. This is intentional to prevent manual changes from being overwritten. Merged in items will be grouped into a group name matching the item name; if an existing group cannot be identified, they will be put into a special placeholder group.
def merge_items_into(items, existing)
	skipped = []
	placed = []
	# placed_into_placeholder_group = []

	items.each do |item|

		placeholder_group = nil
		if placeholder_group = existing_manifest_group_for(item['name'], existing)
			# It already exists. Great.
		elsif placeholder_group = existing_manifest_group_for(item['name'], existing)
			# The placeholder group has already been created. Yay.
		else
			placeholder_group = rekey({
				'name': item['name'],
				'status': 'generated',
				'items': []
			})
			puts "Adding placeholder group to manifest: #{placeholder_group}"
			existing['groups'] << placeholder_group
		end

		if existing_item = existing_manifest_item_for(item, existing)
			skipped << existing_item
		elsif existing_group = existing_manifest_group_for(item['name'], existing)
			# Just drop the item into the existing group.
			improveify_name!(item)
			# puts "#{item['name']} (#{item['path']})"
			existing_group['items'] << item
			placed << item
		# else
		# 	# No group in the existing manifest appears to be a fit, so put the item into a placeholder group.
		# 	placeholder_group['items'] << item
		# 	placed_into_placeholder_group << item
		end
	end
	return [skipped, placed]

end

def report(skipped, placed)
	puts "\nFiles skipped as already present in the manifest: #{skipped.length}"
	# skipped.each do |n| puts "\t#{n['path']} (#{n['name']})" end
	puts "Placed into a group: #{placed.length}"
	placed.each do |n| puts "\t#{[n['path'],n['url']].join(' ')}" end
	# puts "\nPut into a placeholder group:#{placed_into_placeholder_group.length}"
	# placed_into_placeholder_group.each do |n| puts "\t#{n['path']}" end
end

def	write_to_file(path, existing)
	file = File.open(path, 'w')
	file.write(JSON.pretty_generate(existing))
	file.close
end

if(ARGV.length != 3)
	puts HELP
	exit 1
else
	file = File.read(ARGV[1])
	existing = JSON.parse(file)
	items = content_directory_to_item_tree(ARGV[0])
	skipped, placed = merge_items_into(items, existing)
	report(skipped, placed)
	write_to_file(ARGV[2], existing)
	exit 0
end
