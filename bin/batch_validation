#!/usr/bin/env ruby

require 'json'
require 'pp'
require 'open3'
require 'byebug'

require_relative 'lib/common'
include Repository

HELP = <<EOF.freeze

Performs validation against all artifacts. Provide the manifest file as the only argument. XML schema validation on composites is non-recursive. This may take a few minutes. Be patient! If the existing and new manifest files are the same, the existing file will be *overwriten* in place. Be sure you have a backup handy if you're doing this!

The --update or --no-update is required, indicating whether existing passed validations should be re-run or not, respectively.

	USAGE: #{__FILE__} <manifest.json> --(no-)update <new_manifest.json>

	EXAMPLE:
		#{__FILE__} manifest.json manifest-new.json

EOF

# SCRIPT_DIR = File.dirname(File.expand_path(__FILE__))
ARTIFACT_SCHEMA = 'doc/schema/1.3-revised/knowledgeartifact/knowledgedocument.xsd'.freeze
COMPOSITE_SCHEMA = 'doc/schema/composite-draft/knowledgeartifact/compositeknowledgedocument.xsd'.freeze

UPDATE_EXISTING_VALIDATIONS = false

def should_validate(old)
  UPDATE_EXISTING_VALIDATIONS || old.nil? || !old.dig('passed')
end

def validate_composites(root, manifest)
  manifest['groups'].each do |group|
    group['items'].each do |item|
      path = "#{root}/#{item['path']}"
      # puts "#{path}"
      old = item['validation']
      if (COMPOSITE_MIME_TYPES.include? item['mimeType']) && should_validate(old)
        item['validation'] = validate(root + '/' + item['path'], root + '/' + COMPOSITE_SCHEMA)
        pp item
      end
    end
  end
end

def validate_individuals(root, manifest)
  # list = Dir.glob("#{root}/**/*KRprt*.xml", File::FNM_CASEFOLD)
  individuals = []
  manifest['groups'].each do |group|
    group['items'].each do |item|
      path = "#{root}/#{item['path']}"
      # puts "#{path}"
      old = item['validation']
      if (KNART_MIME_TYPES.include? item['mimeType']) && should_validate(old)
        individuals << item
        item['validation'] = validate(root + '/' + item['path'], root + '/' + ARTIFACT_SCHEMA)
        pp item
      end
    end
  end
end

def validate(_file, _schema)
  cmd = "xmllint --noout --schema #{_schema} #{_file}"
  stdout, stderr, status = Open3.capture3(cmd)
  validation = {
    passed: status.exitstatus == 0,
    code: status.exitstatus,
    display: xmllint_status_code(status.exitstatus),
    errors:  nil,
    run_at: Time.now
  }
  validation[:errors] = stderr unless validation[:passed]
  validation
end

def xmllint_status_code(code)
  case code
  when 0
    'valid!'
  when 1
    'Unclassified'
  when 2
    'Error in DTD'
  when 3
    'Validation error'
  when 4
    'Validation error'
  when 5
    'Error in schema compilation'
  when 6
    'Error writing output'
  when 7
    'Error in pattern (generated when --pattern option is used)'
  when 8
    'Error in Reader registration (generated when --chkregister option is used)'
  when 9
    'Out of memory error'
  else
    'Unknown :-/'
  end
end

if ARGV.length != 3
  puts HELP
  exit 1
else
  file = ARGV[0]
  manifest = JSON.parse(File.read(file))
  root = File.dirname(File.expand_path(file))

  if ARGV[1] == '--update'
    UPDATE_EXISTING_VALIDATIONS = true
  end

  # Open the output first so we don't waste time if it's not writable.
  out = File.open(ARGV[2], 'w')

  validate_composites(root, manifest)
  validate_individuals(root, manifest)

  out.write(JSON.pretty_generate(manifest))
  out.close

  exit 0
end
